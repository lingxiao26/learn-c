## 线程同步，信号量，进程锁


### 线程同步

同步：协同步调，按预定的先后次序执行  
线程同步：一个线程执行一个功能调用，在该功能调用未返回之前，为保证数据一致性，其他的线程不能调用该功能  
       
**所有“多个控制流共同操作一个共享资源”的情况，都需要同步**  

共享资源（标准输出）无同步机制的现象 [thrd_shared.c](thrd_shared.c)

     

#### 互斥量 mutex

使用互斥量对共享资源的访问进行控制的步骤：  
       
1. 初始化一个互斥量  
`pthread_mutex_t mutex;`  
`pthread_mutex_init(&mutex, NULL);`  

2. 加锁  
`pthread_mutex_lock(&mutex);`  

3. 对共享资源进行操作  
`do works`  

4. 解锁  
`pthread_mutex_unlock(&mutex);`  

5. 销毁锁  
`pthead_mutex_destroy(&mutex);` 


#### 死锁

1. 线程试图对同一个互斥量进行加锁两次（第二次阻塞，导致线程无法再释放该锁） [thrd_deadlock1.c](thrd_deadlock1.c)
2. 线程T1拥有L1锁，请求获取L2锁；线程T2拥有L2锁，请求获取L1锁。两线程互不相让，导致死锁 [thrd_deadlock2.c](thrd_deadlock2.c)

```
  举个栗子说明第二种情况：
  你家有一个保险柜，里面有7000块钱，保险柜上有两把锁（L1, L2），一把锁的钥匙在你妈那里，另一把锁的钥匙在你爸那。
  你爸想拿着这些钱去买一个肾7，很不巧，你妈也想换手机了，这时候两个人互不相让，谁也买不成了-_-

  怎么解决这种现象呢？
  方法一：把这两把钥匙按顺序放在你手里，你爸妈来抢，谁先抢到第一把钥匙就胜出，这时候两把钥匙就能公平的给一个人了-。-
  方法二：掷骰子，谁的小谁主动把自己的锁打开 （对应线程就是T1尝试获取L2锁，如果发现L2已经被锁住，这时候需主动释放自己的锁（L1））
```
